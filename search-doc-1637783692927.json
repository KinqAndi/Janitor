[{"title":"Getting Started with Janitor","type":0,"sectionRef":"#","url":"docs/intro","content":"Getting Started with Janitor Here are some quick links to get started using Janitor: Installation guideAPI DocsWhy use Janitor?Who uses Janitor?","keywords":""},{"title":"RbxScriptConnection","type":0,"sectionRef":"#","url":"api/RbxScriptConnection","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"RbxScriptConnection","url":"api/RbxScriptConnection#functions","content":" "},{"title":"Disconnect","type":1,"pageTitle":"RbxScriptConnection","url":"api/RbxScriptConnection#Disconnect","content":"&lt;/&gt; RbxScriptConnection:Disconnect() → () Disconnects the Signal. "},{"title":"Why use Janitor?","type":0,"sectionRef":"#","url":"docs/WhyUseJanitor","content":"","keywords":""},{"title":"Ease of use","type":1,"pageTitle":"Why use Janitor?","url":"docs/WhyUseJanitor#ease-of-use","content":"Janitor makes dealing with garbage collection much less annoying and stressful because it manages them all in a nice interface. "},{"title":"Returning","type":1,"pageTitle":"Why use Janitor?","url":"docs/WhyUseJanitor#returning","content":"Janitor:Add() returns the first object passed, which Maid does not. "},{"title":"Custom Cleanup Methods","type":1,"pageTitle":"Why use Janitor?","url":"docs/WhyUseJanitor#custom-cleanup-methods","content":"With Maid, you can't tell it to do anything other than :Destroy(), :Disconnect(), or call something. Janitor allows any method you choose to be called for cleanup. This includes Tween:Stop(), Humanoid:BreakJoints(), or Tool:Deactivate(). You can see this being used in the Janitor:AddPromise() method. "},{"title":"API Consistency","type":1,"pageTitle":"Why use Janitor?","url":"docs/WhyUseJanitor#api-consistency","content":"Janitor:Add() also accepts a custom reference to store under, which keeps the API more consistent. \tJanitor\tMaidAdding an Instance\tJanitor:Add(Instance, &quot;Destroy&quot;)\tMaid:GiveTask(Instance) Adding an Instance under a given index\tJanitor:Add(Instance, &quot;Destroy&quot;, &quot;Index&quot;)\tMaid.Index = Instance "},{"title":"LinkToInstance","type":1,"pageTitle":"Why use Janitor?","url":"docs/WhyUseJanitor#linktoinstance","content":"Janitor also allows linking to an Instance via the Janitor:LinkToInstance() method. This allows the Janitor to cleanup everything added to it when an Instance has its Instance:Destroy() method invoked. "},{"title":"Who uses Janitor?","type":0,"sectionRef":"#","url":"docs/WhoUsesJanitor","content":"Who uses Janitor? Several games both big and small use Janitor as well as many plugins. Armtastic by Mullets Mafia RedBe an Alien: Renewal by PeZsmisticBenchmarker by boatbomberBloopville (NOT RELEASED) by BloopVille TeamRBLX04 by movsbRepoToRoblox by boatbomberScience Simulator by Interbyte StudioStudio Tweaks by PeZsmistic If you want your project featured here, leave a pull request!","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Method #1 - RepoToRoblox","type":1,"pageTitle":"Installation","url":"docs/Installation#method-1---repotoroblox","content":"Using Boatbomber's RepoToRoblox plugin is the easiest way to install in Studio. In the RepoToRoblox widget, enter howmanysmall as the Owner and Janitor as the Repo.Click the Clone Repo button.  "},{"title":"Method #2 - HttpService","type":1,"pageTitle":"Installation","url":"docs/Installation#method-2---httpservice","content":"This method uses HttpService to install Janitor. In Roblox Studio, paste the following command into your command bar.Run the following command: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local HttpService = game:GetService(&quot;HttpService&quot;) local HttpEnabled = HttpService.HttpEnabled HttpService.HttpEnabled = true local function RequestAsync(RequestDictionary) return HttpService:RequestAsync(RequestDictionary) end local function GetAsync(Url, Headers) Headers[&quot;cache-control&quot;] = &quot;no-cache&quot; local Success, ResponseDictionary = pcall(RequestAsync, { Headers = Headers; Method = &quot;GET&quot;; Url = Url; }) if Success then if ResponseDictionary.Success then return ResponseDictionary.Body else return false, string.format(&quot;HTTP %d: %s&quot;, ResponseDictionary.StatusCode, ResponseDictionary.StatusMessage) end else return false, ResponseDictionary end end local function Initify(Root) local InitFile = Root:FindFirstChild(&quot;init&quot;) or Root:FindFirstChild(&quot;init.lua&quot;) or Root:FindFirstChild(&quot;init.client.lua&quot;) or Root:FindFirstChild(&quot;init.server.lua&quot;) if InitFile then InitFile.Name = Root.Name InitFile.Parent = Root.Parent for _, Child in ipairs(Root:GetChildren()) do Child.Parent = InitFile end Root:Destroy() Root = InitFile end for _, Child in ipairs(Root:GetChildren()) do Initify(Child) end return Root end local FilesList = HttpService:JSONDecode(assert(GetAsync( &quot;https://api.github.com/repos/howmanysmall/Janitor/contents/src&quot;, {accept = &quot;application/vnd.github.v3+json&quot;} ))) local Janitor = Instance.new(&quot;Folder&quot;) Janitor.Name = &quot;Janitor&quot; for _, FileData in ipairs(FilesList) do local ModuleScript = Instance.new(&quot;ModuleScript&quot;) ModuleScript.Name = tostring(string.match(FileData.name, &quot;(%w+)%.lua&quot;)) local Success, Source = GetAsync(FileData.download_url, {}) if not Success then ModuleScript.Source = string.format(&quot;-- %s&quot;, tostring(Source)) else ModuleScript.Source = tostring(Success) end ModuleScript.Parent = Janitor end Janitor.Parent = ReplicatedStorage Initify(Janitor) HttpService.HttpEnabled = HttpEnabled "},{"title":"Method 3 - Manual","type":1,"pageTitle":"Installation","url":"docs/Installation#method-3---manual","content":"Visit the latest releaseUnder Assets, click Janitor.rbxm Using Rojo? Put the file into your game directly.Using Roblox Studio? Drag the file onto the viewport. It should insert under Workspace. "},{"title":"Method 4 - Wally","type":1,"pageTitle":"Installation","url":"docs/Installation#method-4---wally","content":"Setup Wally by using wally init.Add howmanysmall/Janitor as a dependency. [dependencies]Janitor = &quot;howmanysmall/janitor@^1.13.13&quot; Copy "},{"title":"Next","type":1,"pageTitle":"Installation","url":"docs/Installation#next","content":"Now, check out the API reference! "},{"title":"Janitor","type":0,"sectionRef":"#","url":"api/Janitor","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Janitor","url":"api/Janitor#functions","content":" "},{"title":"Is","type":1,"pageTitle":"Janitor","url":"api/Janitor#Is","content":"&lt;/&gt; Janitor.Is( Object: any-- The object you are checking. ) → boolean-- true if Object is a Janitor. Determines if the passed object is a Janitor. This checks the metatable directly.  "},{"title":"new","type":1,"pageTitle":"Janitor","url":"api/Janitor#new","content":"&lt;/&gt; Janitor.new() → Janitor Instantiates a new Janitor object.  "},{"title":"Add","type":1,"pageTitle":"Janitor","url":"api/Janitor#Add","content":"&lt;/&gt; Janitor:Add( Object: T,-- The object you want to clean up. MethodName?: string | true,-- The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes Destroy. Index?: any-- The index that can be used to clean up the object manually. ) → T-- The object that was passed as the first argument. Adds an Object to Janitor for later cleanup, where MethodName is the key of the method within Object which should be called at cleanup time. If the MethodName is true the Object itself will be called instead. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Returns the Object. info Objects not given an explicit MethodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to &quot;Disconnect&quot;, functions will be assigned to true, and everything else will default to &quot;Destroy&quot;. Not recommended, but hey, you do you. local Workspace = game:GetService(&quot;Workspace&quot;) local TweenService = game:GetService(&quot;TweenService&quot;) local Obliterator = Janitor.new() local Part = Workspace.Part -- Queue the Part to be Destroyed at Cleanup time Obliterator:Add(Part, &quot;Destroy&quot;) -- Queue function to be called with `true` MethodName Obliterator:Add(print, true) -- This implementation allows you to specify behavior for any object Obliterator:Add(TweenService:Create(Part, TweenInfo.new(1), {Size = Vector3.new(1, 1, 1)}), &quot;Cancel&quot;) -- By passing an Index, the Object will occupy a namespace -- If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing Obliterator:Add(TweenService:Create(Part, TweenInfo.new(1), {Size = Vector3.new(1, 1, 1)}), &quot;Destroy&quot;, &quot;CurrentTween&quot;) import { Workspace, TweenService } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const Obliterator = new Janitor&lt;{ CurrentTween: Tween }&gt;(); const Part = Workspace.FindFirstChild(&quot;Part&quot;) as Part; // Queue the Part to be Destroyed at Cleanup time Obliterator.Add(Part, &quot;Destroy&quot;); // Queue function to be called with `true` MethodName Obliterator.Add(print, true); // This implementation allows you to specify behavior for any object Obliterator.Add(TweenService.Create(Part, new TweenInfo(1), {Size: new Vector3(1, 1, 1)}), &quot;Cancel&quot;); // By passing an Index, the Object will occupy a namespace // If &quot;CurrentTween&quot; already exists, it will call :Remove(&quot;CurrentTween&quot;) before writing Obliterator.Add(TweenService.Create(Part, new TweenInfo(1), {Size: new Vector3(1, 1, 1)}), &quot;Destroy&quot;, &quot;CurrentTween&quot;);   "},{"title":"AddPromise","type":1,"pageTitle":"Janitor","url":"api/Janitor#AddPromise","content":"&lt;/&gt; Janitor:AddPromise( PromiseObject: Promise-- The promise you want to add to the Janitor. ) → Promise Adds a Promise to the Janitor. If the Janitor is cleaned up and the Promise is not completed, the Promise will be cancelled. local Obliterator = Janitor.new() Obliterator:AddPromise(Promise.delay(3)):andThenCall(print, &quot;Finished!&quot;):catch(warn) task.wait(1) Obliterator:Cleanup() import { Janitor } from &quot;@rbxts/janitor&quot;; const Obliterator = new Janitor(); Obliterator.AddPromise(Promise.delay(3)).andThenCall(print, &quot;Finished!&quot;).catch(warn); task.wait(1); Obliterator.Cleanup();   "},{"title":"Remove","type":1,"pageTitle":"Janitor","url":"api/Janitor#Remove","content":"&lt;/&gt; Janitor:Remove( Index: any-- The index you want to remove. ) → Janitor Cleans up whatever Object was set to this namespace by the 3rd parameter of Janitor.Add. local Obliterator = Janitor.new() Obliterator:Add(workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) Obliterator:Remove(&quot;Baseplate&quot;) import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const Obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); Obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); Obliterator.Remove(&quot;Baseplate&quot;);   "},{"title":"Get","type":1,"pageTitle":"Janitor","url":"api/Janitor#Get","content":"&lt;/&gt; Janitor:Get( Index: any-- The index that the object is stored under. ) → any?-- This will return the object if it is found, but it won't return anything if it doesn't exist. Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the task using __index. local Obliterator = Janitor.new() Obliterator:Add(workspace.Baseplate, &quot;Destroy&quot;, &quot;Baseplate&quot;) print(Obliterator:Get(&quot;Baseplate&quot;)) -- Returns Baseplate. import { Workspace } from &quot;@rbxts/services&quot;; import { Janitor } from &quot;@rbxts/janitor&quot;; const Obliterator = new Janitor&lt;{ Baseplate: Part }&gt;(); Obliterator.Add(Workspace.FindFirstChild(&quot;Baseplate&quot;) as Part, &quot;Destroy&quot;, &quot;Baseplate&quot;); print(Obliterator.Get(&quot;Baseplate&quot;)); // Returns Baseplate.   "},{"title":"Cleanup","type":1,"pageTitle":"Janitor","url":"api/Janitor#Cleanup","content":"&lt;/&gt; Janitor:Cleanup() → () Calls each Object's MethodName (or calls the Object if MethodName == true) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback). Obliterator:Cleanup() -- Valid. Obliterator() -- Also valid. Obliterator.Cleanup()   "},{"title":"Destroy","type":1,"pageTitle":"Janitor","url":"api/Janitor#Destroy","content":"&lt;/&gt; Janitor:Destroy() → () Calls Janitor.Cleanup and renders the Janitor unusable. warning Running this will make any attempts to call a function of Janitor error.  "},{"title":"LinkToInstance","type":1,"pageTitle":"Janitor","url":"api/Janitor#LinkToInstance","content":"&lt;/&gt; Janitor:LinkToInstance( Object: Instance,-- The instance you want to link the Janitor to. AllowMultiple?: boolean-- Whether or not to allow multiple links on the same Janitor. ) → RbxScriptConnection-- A pseudo RBXScriptConnection that can be disconnected to prevent the cleanup of LinkToInstance. &quot;Links&quot; this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroyed() and garbage collected. A Janitor may only be linked to one instance at a time, unless AllowMultiple is true. When called with a truthy AllowMultiple parameter, the Janitor will &quot;link&quot; the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy AllowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy AllowMultiple parameter, if applicable. local Obliterator = Janitor.new() Obliterator:Add(function() print(&quot;Cleaning up!&quot;) end, true) do local Folder = Instance.new(&quot;Folder&quot;) Obliterator:LinkToInstance(Folder) Folder:Destroy() end import { Janitor } from &quot;@rbxts/janitor&quot;; const Obliterator = new Janitor(); Obliterator.Add(() =&gt; print(&quot;Cleaning up!&quot;), true); { const Folder = new Instance(&quot;Folder&quot;); Obliterator.LinkToInstance(Folder, false); Folder.Destroy(); } This returns a mock RBXScriptConnection (see: RbxScriptConnection).  "},{"title":"LinkToInstances","type":1,"pageTitle":"Janitor","url":"api/Janitor#LinkToInstances","content":"&lt;/&gt; Janitor:LinkToInstances( ...: Instance-- All the Instances you want linked. ) → Janitor-- A new Janitor that can be used to manually disconnect all LinkToInstances. Links several instances to a new Janitor, which is then returned. "}]